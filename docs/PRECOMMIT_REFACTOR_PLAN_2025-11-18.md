## Пошаговый план рефакторинга для прохождения pre-commit (ruff / mypy / bandit)

Этот файл описывает **поэтапный план**, как безопасно довести проект до состояния,
когда все хуки pre-commit (ruff, mypy, bandit и пр.) проходят без ошибок.
План рассчитан на серию небольших, изолированных PR/коммитов.

---

## Этап 1. Базовая типизация `Database` и фабрики БД

**Цель:** убрать массовые ошибки вида `"<typing special form>" not callable`
и сделать создание `Database()` типобезопасным (вызовы `ORMDatabase()` будут
по возможности убраны или ограничены на следующих этапах).

- **1.1. Завершить и зафиксировать паттерн в `app/database/__init__.py`**
  - Использовать уже существующий алиас `Database = Union[ORMDatabase, LegacyDatabase]` для типов.
  - Для runtime-части экспортировать конкретный класс (ORM или legacy), как сделано сейчас.
  - Для mypy:
    - создать вспомогательную функцию-фабрику, например:
      - `def get_database() -> Database: ...`,
      - и **в коде хэндлеров/сервисов вызывать именно её**, а не `Database()` напрямую.

- **1.2. Поиск и замена прямых вызовов `Database()`**
  - Файлы, где сейчас ругается mypy:
    - `app/filters/group_filter.py`
    - `app/services/master_archive_service.py`
    - `app/services/master_reports_detailed.py`
    - `app/services/realtime_active_orders.py`
    - `app/handlers/order_search.py`
    - `app/handlers/master.py`
    - `app/handlers/admin.py`
    - `app/handlers/dispatcher.py`
    - и др. (по отчету mypy).
  - Для каждого файла: заменить
    - `db = Database()` → `db = get_database()`,
    - `self.db = Database()` → `self.db: Database = get_database()`,
    - в местах, где нужен строго ORM или legacy – явно импортировать `ORMDatabase` / `LegacyDatabase`.

- **1.3. Подготовка временных `type: ignore` только там, где без этого никак**
  - Для самых сложных мест (где логика сильно зависит от реализации) можно докрутить:
    - `db: ORMDatabase | LegacyDatabase = get_database()`,
    - и внутри ветвей `if Config.USE_ORM:`/`else:` развести по типам.
  - В крайнем случае – локальные `# type: ignore[operator]` на вызов фабрики, но **не по всему проекту**.

**Результат этапа:** mypy больше не жалуется на `"<typing special form>" not callable`,
количество ошибок заметно сокращается.

---

## Этап 2. Чистка типизации вокруг Excel и отчётных сервисов

**Цель:** довести до конца mypy/ruff в тех файлах, которые уже активно рефакторили.

- **2.1. `app/services/excel_export.py`**
  - Завершить правки по `_add_orders_by_master_sheet` и `_add_individual_master_sheets`:
    - сигнатуры методов и их вызовы должны совпадать;
    - не должно быть неиспользуемых аргументов (`subheader_font`, `subheader_fill` и т.п.).
  - Привести переменные с неявным типом к явному, например:
    - `for col_idx, value in enumerate(row_data, start=1):` — при необходимости добавить аннотации типа для `row_data`.
  - Проверить словари ширин колонок (`widths`, `column_widths`, `widths_completed`):
    - key: `str`, value: `int` во всех местах;
    - убрать случайные присваивания строк в переменные, ожидающие `int`.

- **2.2. `app/services/reports_service.py`**
  - Мы уже поправили `save_report_to_file`, но нужно:
    - убедиться, что mypy не ругается на `Database` в этом сервисе после внедрения фабрики `get_database()`;
    - проверить, что все асинхронные методы либо не используют блокирующие операции,
      либо помечены `# noqa: ASYNC101`/вынесены в sync-хелперы.

- **2.3. `app/services/master_reports.py` и связанные отчёты master_*_reports**
  - Убедиться, что импорт `aiofiles` помечен корректно (`# type: ignore[import-untyped]` уже добавлен).
  - Проверить, чтобы все листы Excel (особенно там, где настраиваются ширины колонок в цикле)
    не содержали конфликтов типов в циклах `for col, width in column_widths.items():`.

**Результат этапа:** mypy по Excel‑части чистый, Ruff ругается только на общий код (handlers, reports и т.п.).

---

## Этап 3. Структурный рефакторинг хэндлеров (Ruff: PLR/RET/F841)

**Цель:** снизить шум Ruff в критичных местах хэндлеров, не меняя поведение.

- **3.1. `app/handlers/dispatcher.py`**
  - `RET505 Unnecessary else after return`:
    - переписать конструкции вида:
      ```python
      if condition:
          return X
      else:
          return Y
      ```
      на:
      ```python
      if condition:
          return X
      return Y
      ```
  - `PLR0911 Too many return statements`:
    - для крупных функций с > 6 `return`:
      - вынести повторяющиеся ветки в отдельные небольшие вспомогательные функции;
      - оставить одну точку выхода в конце, если это не ухудшает читаемость.
  - `F841 Local variable 'action' / 'order_id' assigned to but never used`:
    - либо реально использовать значение (логирование, дополнительные проверки),
    - либо удалить лишние присваивания и, при необходимости, оставить комментарий.

- **3.2. `app/handlers/master.py`**
  - Аналогично: разрулить `PLR0911` в крупных функциях (особенно в сценариях подтверждений и завершений заявок).
  - Добавить типы для словарей-счётчиков (`by_status`, `by_role`, `by_master` и т.п.):
    - `by_status: dict[str, int] = {}`,
    - `by_master: dict[int, SomeStats] = {}`.

- **3.3. `app/handlers/admin.py` и другие хэндлеры**
  - Привести к типизированным словарям (`by_status`, `by_role`, и т.п.) по аналогии с master/dispatcher.
  - Там, где используются ORM‑объекты и список передаётся в функции, ожидающие legacy-модели,
    рассмотреть варианты:
    - смена аннотаций на `Sequence[...]` вместо `list[...]`,
    - либо перегрузка/унификация типов аргументов хелперов.

**Результат этапа:** Ruff по хэндлерам существенно «успокаивается», остаются в основном только действительно полезные замечания.

- **Практическая ремарка по выполнению этапа 3**
  - Блокирующие замечания Ruff в ключевых файлах (`dispatcher.py`, `master.py`, `developer.py`) уже сняты (S311, F821, базовые I001 и т.п.).
  - Дальнейшее «укрощение» `PLR0911` и глубокий рефакторинг крупных функций имеет смысл делать **точечно, по мере необходимости** — начинать с самых горячих / часто меняющихся хэндлеров.
  - Приведение словарей `by_status` / `by_role` / `by_master` к явным типам (`dict[...]`) тоже можно делать постепенно: при первом серьёзном изменении соответствующей функции.

---

## Этап 4. Нормализация отчётных сервисов (`reports.py`, `order_reports.py`, `realtime_active_orders.py`)

**Цель:** убрать mypy‑ошибки в отчётной логике и унифицировать структуры данных.

- **4.1. Словари агрегатов (by_* словари)**
  - В файлах:
    - `app/services/reports.py`
    - `app/services/order_reports.py`
    - `app/services/master_reports_detailed.py`
  - Для переменных вроде `by_equipment`, `by_status`, `by_master`:
    - явно прописать типы: `dict[str, int]`, `dict[str, SomeDTO]` и т.п.
    - при необходимости — вынести DTO в dataclass (например, `OrderStatusStats`).

- **4.2. Возвращаемые типы с ORM/legacy моделями**
  - Проблемы вида:
    - `list[OrderORM] | list[OrderLegacy]` vs `list[OrderLegacy]` ожидаемый тип.
  - Решения:
    - либо привести возвращаемое значение к единому типу (например, адаптер для ORM → legacy DTO),
    - либо ослабить ожидания в хелпере (использовать `Sequence[OrderBase]`).

- **4.3. `RealtimeActiveOrdersService`**
  - Для `current_table_path` добавить явный тип `str | None` и геттер/сеттер, чтобы mypy не видел там `Any`.

**Результат этапа:** отчётные сервисы перестают быть источником mypy‑ошибок, типы агрегатов становятся явными и предсказуемыми.

---

## Этап 5. Финальная шлифовка Bandit и точечные исключения

**Цель:** оставить только осмысленные, задокументированные исключения правил безопасности.

- **5.1. SQL-конкатенация в `order_repository_extended.py`**
  - Уже помечено `# nosec B608` в критичных местах:
    - построение `WHERE` через `where_clause`,
    - динамический `SET` для `UPDATE`.
  - Проверить, что:
    - `where_clause` и `set_clause` формируются **только из контролируемых перечислений** (status, колонки),
    - нет прямой подстановки пользовательского ввода без валидации.
  - В комментарии к `# nosec` кратко описать причину безопасного использования.

- **5.2. Try/except без пассов**
  - Уже заменено в Excel‑форматтере и части хэндлеров.
  - Остался `app/services/scheduler.py`:
    - либо добавить нормальное логирование ошибки,
    - либо, если игнорируем намеренно — `# nosec B110` + комментарий.

- **5.3. Random в тестовых/утилитарных сценариях**
  - Для всего кода, где `random` используется **только для тестовых/демонстрационных данных**, оставить
    `# nosec B311` + комментарий, что это не криптография.

**Результат этапа:** Bandit проходит либо полностью, либо остаются только осмысленные `# nosec` с объяснением.

---

## Этап 6. Интеграция с pre-commit и стратегия коммитов

**Цель:** сделать рефакторинг безопасным и управляемым.

- **6.1. Разбивать работу на небольшие PR/коммиты по этапам**
  - Этап 1: только фабрика `get_database()` и замены `Database()` → `get_database()`.
  - Этап 2: только Excel‑модули и рядом расположенные отчётные сервисы.
  - Этап 3: только хэндлеры (по одному-двум файлам за коммит).
  - Этап 4–5: отчёты и безопасность.

- **6.2. Локальная проверка перед коммитом**
  - Запускать отдельно:
    - `ruff .`,
    - `mypy app/services/excel_export.py app/services/master_reports.py app/services/reports_service.py` (по модулям),
    - `bandit -r app/services/excel app/services/master_reports.py` и т.п.
  - Только после зелёного статуса локально — `git commit` без `SKIP`.

- **6.3. Временное использование `SKIP` только для блокирующих legacy-проблем**
  - Если нужно срочно залить важный фикс (например, по Excel), а глобальная типизация ещё не готова:
    - допустимо разово сделать:
      - `SKIP="mypy,bandit" git commit ...`,
    - но зафиксировать это в описании PR и привязать к конкретному этапу плана выше.

---

## Рекомендации по приоритету

1. **Сначала** — Этап 1 (Database + фабрики) и Excel‑модули (Этап 2), т.к. они уже частично отрефакторены.
2. **Потом** — хэндлеры (Этап 3), начиная с `dispatcher.py` и `master.py`, так как они дают много шума Ruff/mypy.
3. **Затем** — отчётные сервисы и поиск (`reports.py`, `order_search.py`, `order_reports.py` и т.д.).
4. **В конце** — финальная шлифовка Bandit и точечные `# nosec` с комментариями.

Этот план можно поддерживать актуальным: по завершении каждого этапа дописывать сюда,
какие именно файлы были приведены в порядок и какие правила линтеров теперь считаются обязательными.*** End Patch`"]} !*** End Patch _generated to=functions.apply_patch_toolbar to=functions.apply_patchSecureInputJson осип to=*** Begin Patch
