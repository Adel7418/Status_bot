"""
Regex паттерны и вспомогательные функции для парсинга заявок

Содержит регулярные выражения для извлечения телефонов, времени,
а также функции для определения адресов и временных индикаторов.
"""

import re
from typing import Pattern


# ============================================================================
# REGEX ПАТТЕРНЫ
# ============================================================================

# Паттерн для телефонных номеров
# Примеры: +79001234567, 89001234567, 79001234567, 8(900)123-45-67
PHONE_PATTERN: Pattern[str] = re.compile(
    r"(?:\+?7|8)[\s\-\(\)]?(?:\d{3})[\s\-\(\)]?\d{3}[\s\-]?\d{2}[\s\-]?\d{2}"
)

# Паттерн для временных индикаторов
# Примеры: 14:00, 10.30, с 9 до 12, к 15:00, до 18
TIME_PATTERN: Pattern[str] = re.compile(
    r"""
    (?:
        # Время в формате ЧЧ:ММ или ЧЧ.ММ
        \d{1,2}[:\.]\d{2}
        |
        # Диапазон времени: с X до Y, с X-Y
        (?:с|С)\s+\d{1,2}(?:[:\.]\d{2})?\s+(?:до|по)\s+\d{1,2}(?:[:\.]\d{2})?
        |
        # К/до определённого времени
        (?:к|до|К|До)\s+\d{1,2}(?:[:\.]\d{2})?
        |
        # Просто число (часы)
        (?:в|В)\s+\d{1,2}
    )
    """,
    re.VERBOSE,
)


# ============================================================================
# КЛЮЧЕВЫЕ СЛОВА
# ============================================================================

# Ключевые слова для определения времени в тексте
TIME_KEYWORDS: list[str] = [
    "сегодня",
    "завтра",
    "послезавтра",
    "утром",
    "днём",
    "днем",
    "вечером",
    "ночью",
    "срочно",
    "асап",
    "к",
    "до",
    "после",
    "с",
    "часов",
    "время",
]

# Ключевые слова для определения адреса
# Помогают отличить адрес от описания проблемы
ADDRESS_KEYWORDS: list[str] = [
    "улица",
    "ул",
    "ул.",
    "проспект",
    "пр",
    "пр.",
    "переулок",
    "пер",
    "пер.",
    "дом",
    "д",
    "д.",
    "квартира",
    "кв",
    "кв.",
    "корпус",
    "к",
    "к.",
    "строение",
    "стр",
    "стр.",
    "подъезд",
    "п",
    "этаж",
    "эт",
]


# ============================================================================
# ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
# ============================================================================


def extract_phone(text: str) -> str | None:
    """
    Извлекает номер телефона из текста.

    Args:
        text: Текст сообщения

    Returns:
        Найденный телефонный номер или None

    Examples:
        >>> extract_phone("С/м не крутит барабан. +79001234567")
        "+79001234567"

        >>> extract_phone("ул. Ленина 5, кв. 10, 89001234567")
        "89001234567"

        >>> extract_phone("С/м течёт")
        None
    """
    match = PHONE_PATTERN.search(text)
    if match:
        # Нормализуем номер (убираем лишние символы)
        phone = match.group(0)
        # Убираем все кроме цифр и плюса
        phone = re.sub(r"[^\d+]", "", phone)
        return phone
    return None


def contains_time_indicator(text: str) -> bool:
    """
    Проверяет, содержит ли текст временной индикатор.

    Args:
        text: Строка для проверки

    Returns:
        True если найдены временные индикаторы, иначе False

    Examples:
        >>> contains_time_indicator("завтра к 14:00")
        True

        >>> contains_time_indicator("с 9 до 12")
        True

        >>> contains_time_indicator("С/м не крутит барабан")
        False
    """
    text_lower = text.lower()

    # Проверяем regex паттерн
    if TIME_PATTERN.search(text):
        return True

    # Проверяем ключевые слова
    for keyword in TIME_KEYWORDS:
        if keyword in text_lower:
            return True

    return False


def looks_like_address(text: str) -> bool:
    """
    Определяет, похожа ли строка на адрес.

    Использует эвристику: наличие адресных ключевых слов или
    цифр (номера домов/квартир).

    Args:
        text: Строка для проверки

    Returns:
        True если похоже на адрес, иначе False

    Examples:
        >>> looks_like_address("ул. Ленина 5, кв. 10")
        True

        >>> looks_like_address("Ленина 5-10")
        True

        >>> looks_like_address("не крутит барабан")
        False
    """
    text_lower = text.lower()

    # Проверяем наличие адресных ключевых слов
    for keyword in ADDRESS_KEYWORDS:
        if keyword in text_lower:
            return True

    # Проверяем наличие цифр (может быть номер дома/квартиры)
    # Но только если есть еще и буквы (не просто "123")
    has_digits = bool(re.search(r"\d", text))
    has_letters = bool(re.search(r"[а-яА-Яa-zA-Z]", text))

    if has_digits and has_letters:
        # Дополнительная проверка: если есть тире или дробь между цифрами
        # Например: "Ленина 5-10" или "Гагарина 12/3"
        if re.search(r"\d+[-/]\d+", text):
            return True

        # Если строка короткая (< 30 символов) и содержит цифры с буквами
        # скорее всего это адрес
        if len(text) < 30 and has_digits:
            return True

    return False


def normalize_phone(phone: str) -> str:
    """
    Нормализует номер телефона к стандартному формату.

    Args:
        phone: Телефонный номер в любом формате

    Returns:
        Нормализованный номер в формате +7XXXXXXXXXX

    Examples:
        >>> normalize_phone("89001234567")
        "+79001234567"

        >>> normalize_phone("+79001234567")
        "+79001234567"

        >>> normalize_phone("8 (900) 123-45-67")
        "+79001234567"
    """
    # Убираем все кроме цифр
    digits = re.sub(r"\D", "", phone)

    # Если начинается с 8, заменяем на 7
    if digits.startswith("8"):
        digits = "7" + digits[1:]

    # Добавляем +
    if not digits.startswith("+"):
        digits = "+" + digits

    return digits
