"""
Regex паттерны и вспомогательные функции для парсинга заявок

Содержит регулярные выражения для извлечения телефонов, времени,
а также функции для определения адресов и временных индикаторов.
"""

import re
from re import Pattern


# ============================================================================
# REGEX ПАТТЕРНЫ
# ============================================================================

# Паттерн для телефонных номеров
# Примеры: +79001234567, 89001234567, 79001234567, 8(900)123-45-67
PHONE_PATTERN: Pattern[str] = re.compile(
    r"(?:\+?7|8)[\s\-\(\)]?(?:\d{3})[\s\-\(\)]?\d{3}[\s\-]?\d{2}[\s\-]?\d{2}"
)

# Паттерн для временных индикаторов
# Примеры: 14:00, 10.30, с 9 до 12, к 15:00, до 18
TIME_PATTERN: Pattern[str] = re.compile(
    r"""
    (?:
        # Время в формате ЧЧ:ММ или ЧЧ.ММ
        \d{1,2}[:\.]\d{2}
        |
        # Диапазон времени: с X до Y, с X-Y
        \b(?:с|С)\s+\d{1,2}(?:[:\.]\d{2})?\s+(?:до|по)\s+\d{1,2}(?:[:\.]\d{2})?
        |
        # К/до определённого времени
        \b(?:к|до|К|До)\s+\d{1,2}(?:[:\.]\d{2})?
        |
        # Просто число (часы)
        \b(?:в|В)\s+\d{1,2}\b
    )
    """,
    re.VERBOSE,
)


# ============================================================================
# КЛЮЧЕВЫЕ СЛОВА
# ============================================================================

# Ключевые слова для определения времени в тексте
TIME_KEYWORDS: list[str] = [
    "сегодня",
    "завтра",
    "послезавтра",
    "утром",
    "днём",
    "днем",
    "вечером",
    "ночью",
    "срочно",
    "асап",
    "к",
    "до",
    "после",
    "с",
    "часов",
    "время",
]

# Ключевые слова для определения адреса
# Помогают отличить адрес от описания проблемы
ADDRESS_KEYWORDS: list[str] = [
    "улица",
    "ул",
    "ул.",
    "проспект",
    "пр",
    "пр.",
    "переулок",
    "пер",
    "пер.",
    "дом",
    "д",
    "д.",
    "квартира",
    "кв",
    "кв.",
    "корпус",
    "к",
    "к.",
    "строение",
    "стр",
    "стр.",
    "подъезд",
    "п",
    "этаж",
    "эт",
]


# ============================================================================
# ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
# ============================================================================


def extract_phone(text: str) -> str | None:
    """
    Извлекает номер телефона из текста.

    Args:
        text: Текст сообщения

    Returns:
        Найденный телефонный номер или None

    Examples:
        >>> extract_phone("С/м не крутит барабан. +79001234567")
        "+79001234567"

        >>> extract_phone("ул. Ленина 5, кв. 10, 89001234567")
        "89001234567"

        >>> extract_phone("С/м течёт")
        None
    """
    match = PHONE_PATTERN.search(text)
    if match:
        # Нормализуем номер (убираем лишние символы)
        phone = match.group(0)
        # Убираем все кроме цифр и плюса
        return re.sub(r"[^\d+]", "", phone)
    return None


def contains_time_indicator(text: str) -> bool:
    """
    Проверяет, содержит ли текст временной индикатор.

    Args:
        text: Строка для проверки

    Returns:
        True если найдены временные индикаторы, иначе False

    Examples:
        >>> contains_time_indicator("завтра к 14:00")
        True

        >>> contains_time_indicator("с 9 до 12")
        True

        >>> contains_time_indicator("С/м не крутит барабан")
        False
    """
    text_lower = text.lower()

    # Проверяем regex паттерн
    if TIME_PATTERN.search(text):
        return True

    # Список слишком общих предлогов, которые нужно проверять только в контексте
    context_required = ["с", "к", "до", "после"]

    # Список сильных временных индикаторов
    strong_indicators = ["сегодня", "завтра", "послезавтра", "утром", "днём", "днем", "вечером", "ночью", "срочно", "асап", "время", "часов"]

    # Проверяем сильные индикаторы
    for keyword in strong_indicators:
        if keyword in text_lower:
            return True

    # Для слабых предлогов проверяем контекст: должны быть рядом с цифрами
    for keyword in context_required:
        pattern = r"\b" + re.escape(keyword) + r"\s+\d"
        if re.search(pattern, text_lower):
            return True

    return False


def looks_like_address(text: str) -> bool:  # noqa: PLR0911
    """
    Определяет, похожа ли строка на адрес.

    Использует эвристику: наличие адресных ключевых слов или
    цифр (номера домов/квартир).

    Args:
        text: Строка для проверки

    Returns:
        True если похоже на адрес, иначе False

    Examples:
        >>> looks_like_address("ул. Ленина 5, кв. 10")
        True

        >>> looks_like_address("Ленина 5-10")
        True

        >>> looks_like_address("не крутит барабан")
        False
    """
    text_lower = text.lower()

    # Исключаем строки, которые явно являются временными индикаторами
    # Проверяем TIME_PATTERN и основные временные ключевые слова
    if TIME_PATTERN.search(text):
        return False

    time_keywords_strong = ["завтра", "сегодня", "послезавтра", "утром", "днём", "днем", "вечером", "ночью", "срочно"]
    if any(kw in text_lower for kw in time_keywords_strong):
        return False

    # Проверяем наличие адресных ключевых слов
    # Для однобуквенных сокращений используем границы слов
    for keyword in ADDRESS_KEYWORDS:
        # Для однобуквенных сокращений (без точки) проверяем очень строго:
        # они должны быть с точкой или в конце строки
        if len(keyword.strip(".")) == 1 and "." not in keyword:
            # Однобуквенные без точки пропускаем (слишком общие)
            continue
        # Если ключевое слово короткое (1-2 символа), проверяем как отдельное слово
        if len(keyword.strip(".")) <= 2:
            # Используем \b для границ слова
            pattern = r"\b" + re.escape(keyword) + r"\b"
            if re.search(pattern, text_lower):
                return True
        # Для длинных ключевых слов - обычный поиск подстроки
        elif keyword in text_lower:
            return True

    # Проверяем наличие цифр (может быть номер дома/квартиры)
    # Но только если есть еще и буквы (не просто "123")
    has_digits = bool(re.search(r"\d", text))
    has_letters = bool(re.search(r"[а-яА-Яa-zA-Z]", text))

    if has_digits and has_letters:
        # Дополнительная проверка: если есть тире или дробь между цифрами
        # Например: "Ленина 5-10" или "Гагарина 12/3"
        if re.search(r"\d+[-/]\d+", text):
            return True

        # Если строка короткая (< 30 символов) и содержит цифры с буквами
        # скорее всего это адрес - но только если нет явных признаков проблемы
        # Исключаем строки с типичными словами проблем
        problem_indicators = ["не", "течёт", "течет", "шумит", "крутит", "работает", "включается", "выключается"]
        has_problem_word = any(word in text_lower for word in problem_indicators)

        if len(text) < 30 and has_digits and not has_problem_word:
            return True

    return False


def normalize_phone(phone: str) -> str:
    """
    Нормализует номер телефона к стандартному формату.

    Args:
        phone: Телефонный номер в любом формате

    Returns:
        Нормализованный номер в формате +7XXXXXXXXXX

    Examples:
        >>> normalize_phone("89001234567")
        "+79001234567"

        >>> normalize_phone("+79001234567")
        "+79001234567"

        >>> normalize_phone("8 (900) 123-45-67")
        "+79001234567"
    """
    # Убираем все кроме цифр
    digits = re.sub(r"\D", "", phone)

    # Если начинается с 8, заменяем на 7
    if digits.startswith("8"):
        digits = "7" + digits[1:]

    # Добавляем +
    if not digits.startswith("+"):
        digits = "+" + digits

    return digits
